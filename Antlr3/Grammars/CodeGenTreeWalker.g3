/*
 [The "BSD licence"]
 Copyright (c) 2005-2008 Terence Parr
 All rights reserved.

 Grammar conversion to ANTLR v3 and C#:
 Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:
 1. Redistributions of source code must retain the above copyright
	notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
	notice, this list of conditions and the following disclaimer in the
	documentation and/or other materials provided with the distribution.
 3. The name of the author may not be used to endorse or promote products
	derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/** Walk a grammar and generate code by gradually building up
 *  a bigger and bigger StringTemplate.
 *
 *  Terence Parr
 *  University of San Francisco
 *  June 15, 2004
 */
tree grammar CodeGenTreeWalker;

options
{
	language=CSharp3;
	tokenVocab = ANTLR;
	ASTLabelType=GrammarAST;
}

@header
{
/*
 [The "BSD licence"]
 Copyright (c) 2005-2008 Terence Parr
 All rights reserved.

 Grammar conversion to ANTLR v3 and C#:
 Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:
 1. Redistributions of source code must retain the above copyright
	notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
	notice, this list of conditions and the following disclaimer in the
	documentation and/or other materials provided with the distribution.
 3. The name of the author may not be used to endorse or promote products
	derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

using Antlr3.Analysis;
using Antlr3.Misc;
using Antlr3.Tool;

using BitSet = Antlr.Runtime.BitSet;
using DFA = Antlr.Runtime.DFA;
using StringTemplate = Antlr3.ST.StringTemplate;
using StringTemplateGroup = Antlr3.ST.StringTemplateGroup;
using TokenWithIndex = Antlr.Runtime.CommonToken;
}

@namespace{Antlr3.Grammars}

public
grammar_[Grammar g,
		StringTemplate recognizerST,
		StringTemplate outputFileST,
		StringTemplate headerFileST]
@init
{
	if ( state.backtracking == 0 )
	{
		init(g);
		this.recognizerST = recognizerST;
		this.outputFileST = outputFileST;
		this.headerFileST = headerFileST;
		string superClass = (string)g.getOption("superClass");
		outputOption = (string)g.getOption("output");
		recognizerST.setAttribute("superClass", superClass);
		if ( g.type!=Grammar.LEXER ) {
			recognizerST.setAttribute("ASTLabelType", g.getOption("ASTLabelType"));
		}
		if ( g.type==Grammar.TREE_PARSER && g.getOption("ASTLabelType")==null ) {
			ErrorManager.grammarWarning(ErrorManager.MSG_MISSING_AST_TYPE_IN_TREE_GRAMMAR,
									   g,
									   null,
									   g.name);
		}
		if ( g.type!=Grammar.TREE_PARSER ) {
			recognizerST.setAttribute("labelType", g.getOption("TokenLabelType"));
		}
		$recognizerST.setAttribute("numRules", grammar.Rules.Count);
		$outputFileST.setAttribute("numRules", grammar.Rules.Count);
		$headerFileST.setAttribute("numRules", grammar.Rules.Count);
	}
}
	:	(	^( LEXER_GRAMMAR grammarSpec )
		|	^( PARSER_GRAMMAR grammarSpec )
		|	^( TREE_GRAMMAR grammarSpec )
		|	^( COMBINED_GRAMMAR grammarSpec )
		)
	;

attrScope
	:	^( 'scope' ID ( ^(AMPERSAND .*) )* ACTION )
	;

grammarSpec
	:   name=ID
		(	cmt=DOC_COMMENT
			{
				outputFileST.setAttribute("docComment", $cmt.text);
				headerFileST.setAttribute("docComment", $cmt.text);
			}
		)?
		{
			recognizerST.setAttribute("name", grammar.getRecognizerName());
			outputFileST.setAttribute("name", grammar.getRecognizerName());
			headerFileST.setAttribute("name", grammar.getRecognizerName());
			recognizerST.setAttribute("scopes", grammar.GlobalScopes);
			headerFileST.setAttribute("scopes", grammar.GlobalScopes);
		}
		( ^(OPTIONS .*) )?
		( ^(IMPORT .*) )?
		( ^(TOKENS .*) )?
		(attrScope)*
		( ^(AMPERSAND .*) )*
		rules[recognizerST]
	;

rules[StringTemplate recognizerST]
@init
{
	string ruleName = ((GrammarAST)input.LT(1)).GetChild(0).Text;
	bool generated = grammar.generateMethodForRule(ruleName);
}
	:	(	(	options {k=1;} :
				{generated}? =>
				rST=rule
				{
					if ( $rST.code != null )
					{
						recognizerST.setAttribute("rules", $rST.code);
						outputFileST.setAttribute("rules", $rST.code);
						headerFileST.setAttribute("rules", $rST.code);
					}
				}
			|	^(RULE .*)
			)
			{{
				if ( input.LA(1) == RULE )
				{
					ruleName = ((GrammarAST)input.LT(1)).GetChild(0).Text;
					//System.Diagnostics.Debug.Assert( ruleName == ((GrammarAST)input.LT(1)).enclosingRuleName );
					generated = grammar.generateMethodForRule(ruleName);
				}
			}}
		)+
	;

rule returns [StringTemplate code=null]
@init
{
	string initAction = null;
	// get the dfa for the BLOCK
	GrammarAST block2=(GrammarAST)$start.GetFirstChildWithType(BLOCK);
	Antlr3.Analysis.DFA dfa=block2.LookaheadDFA;
	// init blockNestingLevel so it's block level RULE_BLOCK_NESTING_LEVEL
	// for alts of rule
	blockNestingLevel = RULE_BLOCK_NESTING_LEVEL-1;
	Rule ruleDescr = grammar.getRule($start.GetChild(0).Text);
	currentRuleName = $start.GetChild(0).Text;

	// For syn preds, we don't want any AST code etc... in there.
	// Save old templates ptr and restore later.  Base templates include Dbg.
	StringTemplateGroup saveGroup = templates;
	if ( ruleDescr.isSynPred )
	{
		templates = generator.getBaseTemplates();
	}

	string description = string.Empty;
}
	:	^(	RULE id=ID
			{ System.Diagnostics.Debug.Assert( currentRuleName == $id.text ); }
			(mod=modifier)?
			^(ARG (ARG_ACTION)?)
			^(RET (ARG_ACTION)?)
			(throwsSpec)?
			( ^(OPTIONS .*) )?
			(ruleScopeSpec)?
			( ^(AMPERSAND .*) )*
			b=block["ruleBlock", dfa]
			{
				description =
					grammar.grammarTreeToString((GrammarAST)$start.GetFirstChildWithType(BLOCK),
												false);
				description =
					generator.target.getTargetStringLiteralFromString(description);
				$b.code.setAttribute("description", description);
				// do not generate lexer rules in combined grammar
				string stName = null;
				if ( ruleDescr.isSynPred )
				{
					stName = "synpredRule";
				}
				else if ( grammar.type==Grammar.LEXER )
				{
					if ( currentRuleName.Equals(Grammar.ARTIFICIAL_TOKENS_RULENAME) )
					{
						stName = "tokensRule";
					}
					else
					{
						stName = "lexerRule";
					}
				}
				else
				{
					if ( !(grammar.type==Grammar.COMBINED &&
						 char.IsUpper(currentRuleName[0])) )
					{
						stName = "rule";
					}
				}
				$code = templates.getInstanceOf(stName);
				if ( $code.getName().Equals("rule") )
				{
					$code.setAttribute("emptyRule", grammar.isEmptyRule(block2));
				}
				$code.setAttribute("ruleDescriptor", ruleDescr);
				string memo = (string)grammar.getBlockOption($start,"memoize");
				if ( memo==null )
				{
					memo = (string)grammar.getOption("memoize");
				}
				if ( memo!=null && memo.Equals("true") &&
					 (stName.Equals("rule")||stName.Equals("lexerRule")) )
				{
					$code.setAttribute("memoize", memo!=null && memo.Equals("true"));
				}
			}

			(exceptionGroup[$code])?
			EOR
		)
		{
			if ( $code!=null )
			{
				if ( grammar.type==Grammar.LEXER )
				{
					bool naked =
						currentRuleName.Equals(Grammar.ARTIFICIAL_TOKENS_RULENAME) ||
						($mod.start!=null&&$mod.start.Text.Equals(Grammar.FRAGMENT_RULE_MODIFIER));
					$code.setAttribute("nakedBlock", naked);
				}
				else
				{
					description = grammar.grammarTreeToString($start,false);
					description = generator.target.getTargetStringLiteralFromString(description);
					$code.setAttribute("description", description);
				}
				Rule theRule = grammar.getRule(currentRuleName);
				generator.translateActionAttributeReferencesForSingleScope(
					theRule,
					theRule.Actions
				);
				$code.setAttribute("ruleName", currentRuleName);
				$code.setAttribute("block", $b.code);
				if ( initAction!=null )
				{
					$code.setAttribute("initAction", initAction);
				}
			}
		}
	;
finally { templates = saveGroup; }

modifier
	:	'protected'
	|	'public'
	|	'private'
	|	'fragment'
	;

throwsSpec
	:	^('throws' ID+)
	;

ruleScopeSpec
	:	^( 'scope' ( ^(AMPERSAND .*) )* (ACTION)? ( ID )* )
	;

block[string blockTemplateName, Antlr3.Analysis.DFA dfa]
	 returns [StringTemplate code=null]
options { k=1; }
@init
{
	int altNum = 0;

	blockNestingLevel++;
	if ( state.backtracking == 0 )
	{
		StringTemplate decision = null;
		if ( $dfa != null )
		{
			$code = templates.getInstanceOf($blockTemplateName);
			decision = generator.genLookaheadDecision(recognizerST,$dfa);
			$code.setAttribute("decision", decision);
			$code.setAttribute("decisionNumber", $dfa.DecisionNumber);
			$code.setAttribute("maxK",$dfa.MaxLookaheadDepth);
			$code.setAttribute("maxAlt",$dfa.NumberOfAlts);
		}
		else
		{
			$code = templates.getInstanceOf($blockTemplateName+"SingleAlt");
		}
		$code.setAttribute("blockLevel", blockNestingLevel);
		$code.setAttribute("enclosingBlockLevel", blockNestingLevel-1);
		altNum = 1;
		if ( this.blockNestingLevel==RULE_BLOCK_NESTING_LEVEL ) {
			this.outerAltNum=1;
		}
	}
}
	:	{$start.SetValue!=null}? => setBlock
		{
			$code.setAttribute("alts",$setBlock.code);
		}

	|	^(  BLOCK
			( ^(OPTIONS .*) )? // ignore
			( alt=alternative rew=rewrite
				{
					if ( this.blockNestingLevel==RULE_BLOCK_NESTING_LEVEL )
					{
						this.outerAltNum++;
					}
					// add the rewrite code as just another element in the alt :)
					// (unless it's a " -> ..." rewrite
					// ( -> ... )
					bool etc =
						$rew.start.Type==REWRITE &&
						$rew.start.GetChild(0)!=null &&
						$rew.start.GetChild(0).Type==ETC;
					if ( $rew.code!=null && !etc )
					{
						$alt.code.setAttribute("rew", $rew.code);
					}
					// add this alt to the list of alts for this block
					$code.setAttribute("alts",$alt.code);
					$alt.code.setAttribute("altNum", altNum);
					$alt.code.setAttribute("outerAlt", blockNestingLevel==RULE_BLOCK_NESTING_LEVEL);
					altNum++;
				}
			)+
			EOB
		 )
	;
finally { blockNestingLevel--; }

setBlock returns [StringTemplate code=null]
@init
{
	StringTemplate setcode = null;
	if ( state.backtracking == 0 )
	{
		if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL && grammar.BuildAST )
		{
			Rule r = grammar.getRule(currentRuleName);
			currentAltHasASTRewrite = r.hasRewrite(outerAltNum);
			if ( currentAltHasASTRewrite )
			{
				r.trackTokenReferenceInAlt($start, outerAltNum);
			}
		}
	}
}
	:	^(s=BLOCK .*)
		{
			int i = ((TokenWithIndex)$s.Token).TokenIndex;
			if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL )
			{
				setcode = getTokenElementST("matchRuleBlockSet", "set", $s, null, null);
			}
			else
			{
				setcode = getTokenElementST("matchSet", "set", $s, null, null);
			}
			setcode.setAttribute("elementIndex", i);
			if ( grammar.type!=Grammar.LEXER )
			{
				generator.generateLocalFOLLOW($s,"set",currentRuleName,i);
			}
			setcode.setAttribute("s",
				generator.genSetExpr(templates,$s.SetValue,1,false));
			StringTemplate altcode=templates.getInstanceOf("alt");
			altcode.setAttribute("elements.{el,line,pos}",
								 setcode,
								 $s.Line,
								 $s.CharPositionInLine
								);
			altcode.setAttribute("altNum", 1);
			altcode.setAttribute("outerAlt", blockNestingLevel==RULE_BLOCK_NESTING_LEVEL);
			if ( !currentAltHasASTRewrite && grammar.BuildAST )
			{
				altcode.setAttribute("autoAST", true);
			}
			altcode.setAttribute("treeLevel", rewriteTreeNestingLevel);
			$code = altcode;
		}
	;

setAlternative
	:	^(ALT setElement+ EOA)
	;

exceptionGroup[StringTemplate ruleST]
	:	( exceptionHandler[$ruleST] )+ (finallyClause[$ruleST])?
	|	finallyClause[$ruleST]
	;

exceptionHandler[StringTemplate ruleST]
	:	^('catch' ARG_ACTION ACTION)
		{
			List chunks = generator.translateAction(currentRuleName,$ACTION);
			$ruleST.setAttribute("exceptions.{decl,action}",$ARG_ACTION.text,chunks);
		}
	;

finallyClause[StringTemplate ruleST]
	:	^('finally' ACTION)
		{
			List chunks = generator.translateAction(currentRuleName,$ACTION);
			$ruleST.setAttribute("finally",chunks);
		}
	;

alternative returns [StringTemplate code]
@init
{
	if ( state.backtracking == 0 )
	{
		$code = templates.getInstanceOf("alt");
		/*
		// TODO: can we use Rule.altsWithRewrites???
		if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL ) {
			GrammarAST aRewriteNode = #alternative.findFirstType(REWRITE);
			if ( grammar.buildAST() &&
				 (aRewriteNode!=null||
				 (#alternative.getNextSibling()!=null &&
				  #alternative.getNextSibling().getType()==REWRITE)) )
			{
				currentAltHasASTRewrite = true;
			}
			else {
				currentAltHasASTRewrite = false;
			}
		}
		*/
		if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL && grammar.BuildAST )
		{
			Rule r = grammar.getRule(currentRuleName);
			currentAltHasASTRewrite = r.hasRewrite(outerAltNum);
		}
		string description = grammar.grammarTreeToString($start, false);
		description = generator.target.getTargetStringLiteralFromString(description);
		$code.setAttribute("description", description);
		$code.setAttribute("treeLevel", rewriteTreeNestingLevel);
		if ( !currentAltHasASTRewrite && grammar.BuildAST )
		{
			$code.setAttribute("autoAST", true);
		}
	}
}
	:	^(	a=ALT
			(
				e=element[null,null]
				{
					if ( e!=null )
					{
						$code.setAttribute("elements.{el,line,pos}",
										  $e.code,
										  $e.start.Line,
										  $e.start.CharPositionInLine
										 );
					}
				}
			)+
			EOA
		)
	;

element[GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null]
options { k=1; }
@init
{
	IIntSet elements=null;
	GrammarAST ast = null;
}
	:	^(ROOT e=element[label,$ROOT])
		{ $code = $e.code; }

	|	^(BANG e=element[label,$BANG])
		{ $code = $e.code; }

	|	^( n=NOT notElement[$n, $label, $astSuffix] )
		{ $code = $notElement.code; }

	|	^( ASSIGN alabel=ID e=element[$alabel,$astSuffix] )
		{ $code = $e.code; }

	|	^( PLUS_ASSIGN label2=ID e=element[$label2,$astSuffix] )
		{ $code = $e.code; }

	|	^(CHAR_RANGE a=CHAR_LITERAL b=CHAR_LITERAL)
		{
			$code = templates.getInstanceOf("charRangeRef");
			string low = generator.target.getTargetCharLiteralFromANTLRCharLiteral(generator,$a.text);
			string high = generator.target.getTargetCharLiteralFromANTLRCharLiteral(generator,$b.text);
			$code.setAttribute("a", low);
			$code.setAttribute("b", high);
			if ( label!=null )
			{
				$code.setAttribute("label", $label.Text);
			}
		}

	|	({((GrammarAST)input.LT(1)).SetValue==null}? (BLOCK|OPTIONAL|CLOSURE|POSITIVE_CLOSURE)) => /*{$start.getSetValue()==null}?*/ ebnf
		{ $code = $ebnf.code; }

	|	atom[null, $label, $astSuffix]
		{ $code = $atom.code; }

	|	tree_
		{ $code = $tree_.code; }

	|	element_action
		{ $code = $element_action.code; }

	|   (sp=SEMPRED|sp=GATED_SEMPRED)
		{
			$code = templates.getInstanceOf("validateSemanticPredicate");
			$code.setAttribute("pred", generator.translateAction(currentRuleName,$sp));
			string description = generator.target.getTargetStringLiteralFromString($sp.text);
			$code.setAttribute("description", description);
		}

	|	SYN_SEMPRED // used only in lookahead; don't generate validating pred

	|	^(SYNPRED .*)

	|	^(BACKTRACK_SEMPRED .*)

	|   EPSILON
	;

element_action returns [StringTemplate code=null]
	:	act=ACTION
		{
			$code = templates.getInstanceOf("execAction");
			$code.setAttribute("action", generator.translateAction(currentRuleName,$act));
		}
	|	act2=FORCED_ACTION
		{
			$code = templates.getInstanceOf("execForcedAction");
			$code.setAttribute("action", generator.translateAction(currentRuleName,$act2));
		}
	;

notElement[GrammarAST n, GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null]
@init
{
	IIntSet elements=null;
	string labelText = null;
	if ( label!=null )
	{
		labelText = label.Text;
	}
}
	:	(	assign_c=CHAR_LITERAL
			{
				int ttype=0;
				if ( grammar.type==Grammar.LEXER )
				{
					ttype = Grammar.getCharValueFromGrammarCharLiteral($assign_c.text);
				}
				else
				{
					ttype = grammar.getTokenType($assign_c.text);
				}
				elements = grammar.complement(ttype);
			}
		|	assign_s=STRING_LITERAL
			{
				int ttype=0;
				if ( grammar.type==Grammar.LEXER )
				{
					// TODO: error!
				}
				else
				{
					ttype = grammar.getTokenType($assign_s.text);
				}
				elements = grammar.complement(ttype);
			}
		|	assign_t=TOKEN_REF
			{
				int ttype = grammar.getTokenType($assign_t.text);
				elements = grammar.complement(ttype);
			}
		|	^(assign_st=BLOCK .*)
			{
				elements = $assign_st.SetValue;
				elements = grammar.complement(elements);
			}
		)
		{
			$code = getTokenElementST("matchSet",
									 "set",
									 (GrammarAST)$n.GetChild(0),
									 astSuffix,
									 labelText);
			$code.setAttribute("s",generator.genSetExpr(templates,elements,1,false));
			int i = ((TokenWithIndex)n.Token).TokenIndex;
			$code.setAttribute("elementIndex", i);
			if ( grammar.type!=Grammar.LEXER )
			{
				generator.generateLocalFOLLOW(n,"set",currentRuleName,i);
			}
		}
	;

ebnf returns [StringTemplate code=null]
@init
{
	Antlr3.Analysis.DFA dfa=null;
	GrammarAST b = (GrammarAST)$start.GetChild(0);
	GrammarAST eob = (GrammarAST)b.getLastChild(); // loops will use EOB DFA
}
	:	(	{ dfa = $start.LookaheadDFA; }
			blk=block["block", dfa]
			{ $code = $blk.code; }
		|	{ dfa = $start.LookaheadDFA; }
			^( OPTIONAL blk=block["optionalBlock", dfa] )
			{ $code = $blk.code; }
		|	{ dfa = eob.LookaheadDFA; }
			^( CLOSURE blk=block["closureBlock", dfa] )
			{ $code = $blk.code; }
		|	{ dfa = eob.LookaheadDFA; }
			^( POSITIVE_CLOSURE blk=block["positiveClosureBlock", dfa] )
			{ $code = $blk.code; }
		)
		{
			string description = grammar.grammarTreeToString($start, false);
			description = generator.target.getTargetStringLiteralFromString(description);
			$code.setAttribute("description", description);
		}
	;

tree_ returns [StringTemplate code]
@init
{
	rewriteTreeNestingLevel++;
	GrammarAST rootSuffix = null;
	if ( state.backtracking == 0 )
	{
		$code = templates.getInstanceOf("tree");
		NFAState afterDOWN = (NFAState)$start.NFATreeDownState.getTransition(0).target;
		LookaheadSet s = grammar.LOOK(afterDOWN);
		if ( s.member(Label.UP) ) {
			// nullable child list if we can see the UP as the next token
			// we need an "if ( input.LA(1)==Token.DOWN )" gate around
			// the child list.
			$code.setAttribute("nullableChildList", "true");
		}
		$code.setAttribute("enclosingTreeLevel", rewriteTreeNestingLevel-1);
		$code.setAttribute("treeLevel", rewriteTreeNestingLevel);
		Rule r = grammar.getRule(currentRuleName);
		if ( grammar.BuildAST && !r.hasRewrite(outerAltNum) ) {
			rootSuffix = new GrammarAST(ROOT,"ROOT");
		}
	}
}
	:	^(	TREE_BEGIN
			el=element[null,rootSuffix]
			{
				$code.setAttribute("root.{el,line,pos}",
								  $el.code,
								  $el.start.Line,
								  $el.start.CharPositionInLine
								  );
			}
			// push all the immediately-following actions out before children
			// so actions aren't guarded by the "if (input.LA(1)==Token.DOWN)"
			// guard in generated code.
			(	(element_action) =>
				act=element_action
				{
					$code.setAttribute("actionsAfterRoot.{el,line,pos}",
									  $act.code,
									  $act.start.Line,
									  $act.start.CharPositionInLine
									);
				}
			)*
			(	 el=element[null,null]
				 {
				 $code.setAttribute("children.{el,line,pos}",
								  $el.code,
								  $el.start.Line,
								  $el.start.CharPositionInLine
								  );
				 }
			)*
		)
	;
finally { rewriteTreeNestingLevel--; }

atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix] 
	returns [StringTemplate code=null]
@init
{
	string labelText=null;
	if ( state.backtracking == 0 )
	{
		if ( label!=null )
		{
			labelText = label.Text;
		}
		if ( grammar.type!=Grammar.LEXER &&
			 ($start.Type==RULE_REF||$start.Type==TOKEN_REF||
			  $start.Type==CHAR_LITERAL||$start.Type==STRING_LITERAL) )
		{
			Rule encRule = grammar.getRule(((GrammarAST)$start).enclosingRuleName);
			if ( encRule!=null && encRule.hasRewrite(outerAltNum) && astSuffix!=null )
			{
				ErrorManager.grammarError(ErrorManager.MSG_AST_OP_IN_ALT_WITH_REWRITE,
										  grammar,
										  ((GrammarAST)$start).Token,
										  ((GrammarAST)$start).enclosingRuleName,
										  outerAltNum);
				astSuffix = null;
			}
		}
	}
}
	:   ^( r=RULE_REF (rarg=ARG_ACTION)? )
		{
			grammar.checkRuleReference(scope, $r, $rarg, currentRuleName);
			string scopeName = null;
			if ( scope!=null ) {
				scopeName = scope.Text;
			}
			Rule rdef = grammar.getRule(scopeName, $r.text);
			// don't insert label=r() if $label.attr not used, no ret value, ...
			if ( !rdef.HasReturnValue ) {
				labelText = null;
			}
			$code = getRuleElementST("ruleRef", $r.text, $r, astSuffix, labelText);
			$code.setAttribute("rule", rdef);
			if ( scope!=null ) { // scoped rule ref
				Grammar scopeG = grammar.composite.getGrammar(scope.Text);
				$code.setAttribute("scope", scopeG);
			}
			else if ( rdef.grammar != this.grammar ) { // nonlocal
				// if rule definition is not in this grammar, it's nonlocal
				IList<Grammar> rdefDelegates = rdef.grammar.getDelegates();
				if ( rdefDelegates.Contains(this.grammar) ) {
					$code.setAttribute("scope", rdef.grammar);
				}
				else {
					// defining grammar is not a delegate, scope all the
					// back to root, which has delegate methods for all
					// rules.  Don't use scope if we are root.
					if ( this.grammar != rdef.grammar.composite.delegateGrammarTreeRoot.grammar ) {
						$code.setAttribute("scope",
										  rdef.grammar.composite.delegateGrammarTreeRoot.grammar);
					}
				}
			}

			if ( $rarg!=null ) {
				List args = generator.translateAction(currentRuleName,$rarg);
				$code.setAttribute("args", args);
			}
			int i = ((TokenWithIndex)r.Token).TokenIndex;
			$code.setAttribute("elementIndex", i);
			generator.generateLocalFOLLOW($r,$r.text,currentRuleName,i);
			$r.code = $code;
		}

	|	^( t=TOKEN_REF (targ=ARG_ACTION)? )
		{
			if ( currentAltHasASTRewrite && $t.terminalOptions!=null &&
				$t.terminalOptions[Grammar.defaultTokenOption]!=null )
			{
				ErrorManager.grammarError(ErrorManager.MSG_HETERO_ILLEGAL_IN_REWRITE_ALT,
										grammar,
										((GrammarAST)($t)).Token,
										$t.text);
			}
			grammar.checkRuleReference(scope, $t, $targ, currentRuleName);
			if ( grammar.type==Grammar.LEXER )
			{
				if ( grammar.getTokenType($t.text)==Label.EOF )
				{
					$code = templates.getInstanceOf("lexerMatchEOF");
				}
				else
				{
					$code = templates.getInstanceOf("lexerRuleRef");
					if ( isListLabel(labelText) )
					{
						$code = templates.getInstanceOf("lexerRuleRefAndListLabel");
					}
					string scopeName = null;
					if ( scope!=null )
					{
						scopeName = scope.Text;
					}
					Rule rdef2 = grammar.getRule(scopeName, $t.text);
					$code.setAttribute("rule", rdef2);
					if ( scope!=null )
					{ // scoped rule ref
						Grammar scopeG = grammar.composite.getGrammar(scope.Text);
						$code.setAttribute("scope", scopeG);
					}
					else if ( rdef2.grammar != this.grammar )
					{ // nonlocal
						// if rule definition is not in this grammar, it's nonlocal
						$code.setAttribute("scope", rdef2.grammar);
					}
					if ( $targ!=null )
					{
						List args = generator.translateAction(currentRuleName,$targ);
						$code.setAttribute("args", args);
					}
				}
				int i = ((TokenWithIndex)$t.Token).TokenIndex;
				$code.setAttribute("elementIndex", i);
				if ( label!=null )
					$code.setAttribute("label", labelText);
			}
			else
			{
				$code = getTokenElementST("tokenRef", $t.text, $t, astSuffix, labelText);
				string tokenLabel =
					generator.getTokenTypeAsTargetLabel(grammar.getTokenType(t.Text));
				$code.setAttribute("token",tokenLabel);
				if ( !currentAltHasASTRewrite && $t.terminalOptions!=null )
				{ 
					$code.setAttribute("hetero",$t.terminalOptions[Grammar.defaultTokenOption]);
				}
				int i = ((TokenWithIndex)$t.Token).TokenIndex;
				$code.setAttribute("elementIndex", i);
				generator.generateLocalFOLLOW($t,tokenLabel,currentRuleName,i);
			}
			$t.code = $code;
		}

	|	c=CHAR_LITERAL 
		{
			if ( grammar.type==Grammar.LEXER )
			{
				$code = templates.getInstanceOf("charRef");
				$code.setAttribute("char",
				   generator.target.getTargetCharLiteralFromANTLRCharLiteral(generator,$c.text));
				if ( label!=null )
				{
					$code.setAttribute("label", labelText);
				}
			}
			else { // else it's a token type reference
				$code = getTokenElementST("tokenRef", "char_literal", $c, astSuffix, labelText);
				string tokenLabel = generator.getTokenTypeAsTargetLabel(grammar.getTokenType($c.text));
				$code.setAttribute("token",tokenLabel);
				if ( $c.terminalOptions!=null ) {
					$code.setAttribute("hetero",$c.terminalOptions[Grammar.defaultTokenOption]);
				}
				int i = ((TokenWithIndex)$c.Token).TokenIndex;
				$code.setAttribute("elementIndex", i);
				generator.generateLocalFOLLOW($c,tokenLabel,currentRuleName,i);
			}
		}

	|	s=STRING_LITERAL
		{
			if ( grammar.type==Grammar.LEXER )
			{
				$code = templates.getInstanceOf("lexerStringRef");
				$code.setAttribute("string",
					generator.target.getTargetStringLiteralFromANTLRStringLiteral(generator,$s.text));
				if ( label!=null )
				{
					$code.setAttribute("label", labelText);
				}
			}
			else
			{ // else it's a token type reference
				$code = getTokenElementST("tokenRef", "string_literal", $s, astSuffix, labelText);
				string tokenLabel =
					generator.getTokenTypeAsTargetLabel(grammar.getTokenType($s.text));
				$code.setAttribute("token",tokenLabel);
				if ( $s.terminalOptions!=null )
				{
					$code.setAttribute("hetero",$s.terminalOptions[Grammar.defaultTokenOption]);
				}
				int i = ((TokenWithIndex)$s.Token).TokenIndex;
				$code.setAttribute("elementIndex", i);
				generator.generateLocalFOLLOW($s,tokenLabel,currentRuleName,i);
			}
		}

	|	w=WILDCARD
		{
			$code = getWildcardST($w,astSuffix,labelText);
			$code.setAttribute("elementIndex", ((TokenWithIndex)$w.Token).TokenIndex);
		}

	|	^(DOT ID a=atom[$ID, label, astSuffix]) // scope override on rule or token
		{ $code = $a.code; }

	|	set[label,astSuffix]
		{ $code = $set.code; }
	;

ast_suffix
	:	ROOT
	|	BANG
	;

set[GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null]
@init
{
	string labelText=null;
	if ( $label!=null )
	{
		labelText = $label.Text;
	}
}
	:	^(s=BLOCK .*) // only care that it's a BLOCK with setValue!=null
		{
			$code = getTokenElementST("matchSet", "set", $s, astSuffix, labelText);
			int i = ((TokenWithIndex)$s.Token).TokenIndex;
			$code.setAttribute("elementIndex", i);
			if ( grammar.type!=Grammar.LEXER )
			{
				generator.generateLocalFOLLOW($s,"set",currentRuleName,i);
			}
			$code.setAttribute("s", generator.genSetExpr(templates,$s.SetValue,1,false));
		}
	;

setElement
	:	CHAR_LITERAL
	|	TOKEN_REF
	|	STRING_LITERAL
	|	^(CHAR_RANGE CHAR_LITERAL CHAR_LITERAL)
	;

// REWRITE stuff

rewrite returns [StringTemplate code=null]
@init
{
	if ( state.backtracking == 0 )
	{
		if ( $start.Type==REWRITE )
		{
			if ( generator.grammar.BuildTemplate )
			{
				$code = templates.getInstanceOf("rewriteTemplate");
			}
			else
			{
				$code = templates.getInstanceOf("rewriteCode");
				$code.setAttribute("treeLevel", OUTER_REWRITE_NESTING_LEVEL);
				$code.setAttribute("rewriteBlockLevel", OUTER_REWRITE_NESTING_LEVEL);
				$code.setAttribute("referencedElementsDeep",
								  getTokenTypesAsTargetLabels($start.rewriteRefsDeep));
				HashSet<string> tokenLabels =
					grammar.getLabels($start.rewriteRefsDeep, Grammar.TOKEN_LABEL);
				HashSet<string> tokenListLabels =
					grammar.getLabels($start.rewriteRefsDeep, Grammar.TOKEN_LIST_LABEL);
				HashSet<string> ruleLabels =
					grammar.getLabels($start.rewriteRefsDeep, Grammar.RULE_LABEL);
				HashSet<string> ruleListLabels =
					grammar.getLabels($start.rewriteRefsDeep, Grammar.RULE_LIST_LABEL);
				HashSet<string> wildcardLabels =
					grammar.getLabels($start.rewriteRefsDeep, Grammar.WILDCARD_TREE_LABEL);
				HashSet<string> wildcardListLabels =
					grammar.getLabels($start.rewriteRefsDeep, Grammar.WILDCARD_TREE_LIST_LABEL);
				// just in case they ref $r for "previous value", make a stream
				// from retval.tree
				StringTemplate retvalST = templates.getInstanceOf("prevRuleRootRef");
				ruleLabels.Add(retvalST.ToString());
				$code.setAttribute("referencedTokenLabels", tokenLabels);
				$code.setAttribute("referencedTokenListLabels", tokenListLabels);
				$code.setAttribute("referencedRuleLabels", ruleLabels);
				$code.setAttribute("referencedRuleListLabels", ruleListLabels);
				$code.setAttribute("referencedWildcardLabels", wildcardLabels);
				$code.setAttribute("referencedWildcardListLabels", wildcardListLabels);
			}
		}
		else
		{
				$code = templates.getInstanceOf("noRewrite");
				$code.setAttribute("treeLevel", OUTER_REWRITE_NESTING_LEVEL);
				$code.setAttribute("rewriteBlockLevel", OUTER_REWRITE_NESTING_LEVEL);
		}
	}
}
	:	(
			{rewriteRuleRefs = new HashSet<object>();}
			^( r=REWRITE (pred=SEMPRED)? alt=rewrite_alternative )
			{
				rewriteBlockNestingLevel = OUTER_REWRITE_NESTING_LEVEL;
				List predChunks = null;
				if ( $pred!=null )
				{
					//predText = #pred.getText();
					predChunks = generator.translateAction(currentRuleName,$pred);
				}
				string description =
					grammar.grammarTreeToString($r,false);
				description = generator.target.getTargetStringLiteralFromString(description);
				$code.setAttribute("alts.{pred,alt,description}",
								  predChunks,
								  alt,
								  description);
				pred=null;
			}
		)*
	;

rewrite_block[string blockTemplateName] returns [StringTemplate code=null]
@init
{
	rewriteBlockNestingLevel++;
	StringTemplate save_currentBlockST = currentBlockST;
	if ( state.backtracking == 0 )
	{
		$code = templates.getInstanceOf(blockTemplateName);
		currentBlockST = $code;
		$code.setAttribute("rewriteBlockLevel", rewriteBlockNestingLevel);
	}
}
	:	^(	BLOCK
			{
				currentBlockST.setAttribute("referencedElementsDeep",
					getTokenTypesAsTargetLabels($BLOCK.rewriteRefsDeep));
				currentBlockST.setAttribute("referencedElements",
					getTokenTypesAsTargetLabels($BLOCK.rewriteRefsShallow));
			}
			alt=rewrite_alternative
			EOB
		)
		{
			$code.setAttribute("alt", $alt.code);
		}
	;
finally { rewriteBlockNestingLevel--; currentBlockST = save_currentBlockST; }

rewrite_alternative returns [StringTemplate code=null]
	:	{generator.grammar.BuildAST}?
		^(	a=ALT {$code=templates.getInstanceOf("rewriteElementList");}
			(	(
					el=rewrite_element
					{$code.setAttribute("elements.{el,line,pos}",
										$el.code,
										$el.start.Line,
										$el.start.CharPositionInLine
										);
					}
				)+
			|	EPSILON
				{$code.setAttribute("elements.{el,line,pos}",
								   templates.getInstanceOf("rewriteEmptyAlt"),
								   $a.Line,
								   $a.CharPositionInLine
								   );
				}
			)
			EOA
		 )

	|	{generator.grammar.BuildTemplate}? rewrite_template
		{ $code = $rewrite_template.code; }

	|	// reproduce same input (only AST at moment)
		ETC
	;

rewrite_element returns [StringTemplate code=null]
@init
{
	IIntSet elements=null;
	GrammarAST ast = null;
}
	:	rewrite_atom[false]
		{ $code = $rewrite_atom.code; }
	|	rewrite_ebnf
		{ $code = $rewrite_ebnf.code; }
	|	rewrite_tree
		{ $code = $rewrite_tree.code; }
	;

rewrite_ebnf returns [StringTemplate code=null]
	:	^( OPTIONAL rewrite_block["rewriteOptionalBlock"] )
		{ $code = $rewrite_block.code; }
		{
			string description = grammar.grammarTreeToString($start, false);
			description = generator.target.getTargetStringLiteralFromString(description);
			$code.setAttribute("description", description);
		}
	|	^( CLOSURE rewrite_block["rewriteClosureBlock"] )
		{ $code = $rewrite_block.code; }
		{
			string description = grammar.grammarTreeToString($start, false);
			description = generator.target.getTargetStringLiteralFromString(description);
			$code.setAttribute("description", description);
		}
	|	^( POSITIVE_CLOSURE rewrite_block["rewritePositiveClosureBlock"] )
		{ $code = $rewrite_block.code; }
		{
			string description = grammar.grammarTreeToString($start, false);
			description = generator.target.getTargetStringLiteralFromString(description);
			$code.setAttribute("description", description);
		}
	;

rewrite_tree returns [StringTemplate code]
@init
{
	rewriteTreeNestingLevel++;
	if ( state.backtracking == 0 )
	{
		$code = templates.getInstanceOf("rewriteTree");
		$code.setAttribute("treeLevel", rewriteTreeNestingLevel);
		$code.setAttribute("enclosingTreeLevel", rewriteTreeNestingLevel-1);
	}
}
	:	^(	TREE_BEGIN
			r=rewrite_atom[true]
			{
				$code.setAttribute("root.{el,line,pos}",
								   $r.code,
								   $r.start.Line,
								   $r.start.CharPositionInLine
								  );
			}
			(
			  el=rewrite_element
			  {
				$code.setAttribute("children.{el,line,pos}",
									$el.code,
									$el.start.Line,
									$el.start.CharPositionInLine
									);
			  }
			)*
		)
		{
			string description = grammar.grammarTreeToString($start, false);
			description = generator.target.getTargetStringLiteralFromString(description);
			$code.setAttribute("description", description);
		}
	;
finally { rewriteTreeNestingLevel--; }

rewrite_atom[bool isRoot] returns [StringTemplate code=null]
	:   r=RULE_REF
		{
			string ruleRefName = $r.text;
			string stName = "rewriteRuleRef";
			if ( isRoot )
			{
				stName += "Root";
			}
			$code = templates.getInstanceOf(stName);
			$code.setAttribute("rule", ruleRefName);
			if ( grammar.getRule(ruleRefName)==null )
			{
				ErrorManager.grammarError(ErrorManager.MSG_UNDEFINED_RULE_REF,
										  grammar,
										  ((GrammarAST)($r)).Token,
										  ruleRefName);
				$code = new StringTemplate(); // blank; no code gen
			}
			else if ( grammar.getRule(currentRuleName)
						 .getRuleRefsInAlt(ruleRefName,outerAltNum)==null )
			{
				ErrorManager.grammarError(ErrorManager.MSG_REWRITE_ELEMENT_NOT_PRESENT_ON_LHS,
										  grammar,
										  ((GrammarAST)($r)).Token,
										  ruleRefName);
				$code = new StringTemplate(); // blank; no code gen
			}
			else
			{
				// track all rule refs as we must copy 2nd ref to rule and beyond
				if ( !rewriteRuleRefs.Contains(ruleRefName) )
				{
					rewriteRuleRefs.Add(ruleRefName);
				}
			}
		}

	|
		(	^(tk=TOKEN_REF (arg=ARG_ACTION)?)
		|	cl=CHAR_LITERAL
		|	sl=STRING_LITERAL
		)
		{
			GrammarAST term = ($tk) ?? ($cl) ?? ($sl);
			string tokenName = $start.Token.Text;
			string stName = "rewriteTokenRef";
			Rule rule = grammar.getRule(currentRuleName);
			ICollection<string> tokenRefsInAlt = rule.getTokenRefsInAlt(outerAltNum);
			bool createNewNode = !tokenRefsInAlt.Contains(tokenName) || $arg!=null;
			object hetero = null;
			if ( term.terminalOptions!=null )
			{
				hetero = term.terminalOptions[Grammar.defaultTokenOption];
			}
			if ( createNewNode )
			{
				stName = "rewriteImaginaryTokenRef";
			}
			if ( isRoot )
			{
				stName += "Root";
			}
			$code = templates.getInstanceOf(stName);
			$code.setAttribute("hetero", hetero);
			if ( $arg!=null )
			{
				List args = generator.translateAction(currentRuleName,$arg);
				$code.setAttribute("args", args);
			}
			$code.setAttribute("elementIndex", ((TokenWithIndex)$start.Token).TokenIndex);
			int ttype = grammar.getTokenType(tokenName);
			string tok = generator.getTokenTypeAsTargetLabel(ttype);
			$code.setAttribute("token", tok);
			if ( grammar.getTokenType(tokenName)==Label.INVALID )
			{
				ErrorManager.grammarError(ErrorManager.MSG_UNDEFINED_TOKEN_REF_IN_REWRITE,
										  grammar,
										  ((GrammarAST)($start)).Token,
										  tokenName);
				$code = new StringTemplate(); // blank; no code gen
			}
		}

	|	LABEL
		{
			string labelName = $LABEL.text;
			Rule rule = grammar.getRule(currentRuleName);
			Grammar.LabelElementPair pair = rule.getLabel(labelName);
			if ( labelName.Equals(currentRuleName) )
			{
				// special case; ref to old value via $ rule
				if ( rule.hasRewrite(outerAltNum) &&
					 rule.getRuleRefsInAlt(outerAltNum).Contains(labelName) )
				{
					ErrorManager.grammarError(ErrorManager.MSG_RULE_REF_AMBIG_WITH_RULE_IN_ALT,
											  grammar,
											  ((GrammarAST)($LABEL)).Token,
											  labelName);
				}
				StringTemplate labelST = templates.getInstanceOf("prevRuleRootRef");
				$code = templates.getInstanceOf("rewriteRuleLabelRef"+(isRoot?"Root":""));
				$code.setAttribute("label", labelST);
			}
			else if ( pair==null )
			{
				ErrorManager.grammarError(ErrorManager.MSG_UNDEFINED_LABEL_REF_IN_REWRITE,
										  grammar,
										  ((GrammarAST)($LABEL)).Token,
										  labelName);
				$code = new StringTemplate();
			}
			else
			{
				string stName = null;
				switch ( pair.type )
				{
				case Grammar.TOKEN_LABEL :
					stName = "rewriteTokenLabelRef";
					break;
				case Grammar.WILDCARD_TREE_LABEL :
					stName = "rewriteWildcardLabelRef";
					break;
				case Grammar.WILDCARD_TREE_LIST_LABEL:
					stName = "rewriteRuleListLabelRef"; // acts like rule ref list for ref
					break;
				case Grammar.RULE_LABEL :
					stName = "rewriteRuleLabelRef";
					break;
				case Grammar.TOKEN_LIST_LABEL :
					stName = "rewriteTokenListLabelRef";
					break;
				case Grammar.RULE_LIST_LABEL :
					stName = "rewriteRuleListLabelRef";
					break;
				}
				if ( isRoot )
				{
					stName += "Root";
				}
				$code = templates.getInstanceOf(stName);
				$code.setAttribute("label", labelName);
			}
		}

	|	ACTION
		{
			// actions in rewrite rules yield a tree object
			string actText = $ACTION.text;
			List chunks = generator.translateAction(currentRuleName,$ACTION);
			$code = templates.getInstanceOf("rewriteNodeAction"+(isRoot?"Root":""));
			$code.setAttribute("action", chunks);
		}
	;

public
rewrite_template returns [StringTemplate code=null]
	:	^( ALT EPSILON EOA ) {$code=templates.getInstanceOf("rewriteEmptyTemplate");}
	|	^(	TEMPLATE (id=ID|ind=ACTION)
			{
				if ( $id!=null && $id.text.Equals("template") )
				{
						$code = templates.getInstanceOf("rewriteInlineTemplate");
				}
				else if ( $id!=null )
				{
						$code = templates.getInstanceOf("rewriteExternalTemplate");
						$code.setAttribute("name", $id.text);
				}
				else if ( $ind!=null )
				{ // must be \%({expr})(args)
					$code = templates.getInstanceOf("rewriteIndirectTemplate");
					List chunks=generator.translateAction(currentRuleName,$ind);
					$code.setAttribute("expr", chunks);
				}
			}
			^(	ARGLIST
				(	^( ARG arg=ID a=ACTION
					{
						// must set alt num here rather than in define.g
						// because actions like \%foo(name={\$ID.text}) aren't
						// broken up yet into trees.
						$a.outerAltNum = this.outerAltNum;
						List chunks = generator.translateAction(currentRuleName,$a);
						$code.setAttribute("args.{name,value}", $arg.text, chunks);
					}
					)
				)*
			)
			(	DOUBLE_QUOTE_STRING_LITERAL
				{
					string sl = $DOUBLE_QUOTE_STRING_LITERAL.text;
					string t = sl.Substring( 1, sl.Length - 2 ); // strip quotes
					t = generator.target.getTargetStringLiteralFromString(t);
					$code.setAttribute("template",t);
				}
			|	DOUBLE_ANGLE_STRING_LITERAL
				{
					string sl = $DOUBLE_ANGLE_STRING_LITERAL.text;
					string t = sl.Substring( 2, sl.Length - 4 ); // strip double angle quotes
					t = generator.target.getTargetStringLiteralFromString(t);
					$code.setAttribute("template",t);
				}
			)?
		)

	|	act=ACTION
		{
			// set alt num for same reason as ARGLIST above
			$act.outerAltNum = this.outerAltNum;
			$code=templates.getInstanceOf("rewriteAction");
			$code.setAttribute("action",
							  generator.translateAction(currentRuleName,$act));
		}
	;
